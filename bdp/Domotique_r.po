THEORY ProofList IS
_f(1) & _f(2) & _f(3) & _f(4) & _f(26) & getObjetInvalide.1,(_f(6) => _f(28));
_f(1) & _f(2) & _f(3) & _f(4) & _f(26) & getObjetActif.1,(_f(6) => _f(27));
_f(1) & _f(2) & _f(3) & _f(4) & _f(17) & activerObjetFixe.1,(_f(18) & _f(19) & _f(20) & _f(21) & _f(22) & _f(23) & _f(24) => _f(25));
_f(1) & _f(2) & _f(3) & _f(4) & _f(15) & desactiverObjet.1,(_f(6) & _f(9) => _f(16));
_f(1) & _f(2) & _f(3) & _f(4) & _f(13) & activerObjetMobile.1,(_f(6) & _f(9) => _f(14));
_f(1) & _f(2) & _f(3) & _f(4) & _f(5) & addObjet.3,(_f(6) & _f(11) => _f(12));
_f(1) & _f(2) & _f(3) & _f(4) & _f(5) & addObjet.2,(_f(6) & _f(9) => _f(10));
_f(1) & _f(2) & _f(3) & _f(4) & _f(5) & addObjet.1,(_f(6) & _f(7) => _f(8))
END
&
THEORY Formulas IS
((NAT) = (((0) .. (2147483647)))) & ((INT) = (((-2147483647) .. (2147483647))));
((1..2)*{CATEGORIE}): FIN(NATURAL*{CATEGORIE}) & not(((1..2)*{CATEGORIE}) = {}) & ((1..3)*{ETAT}): FIN(NATURAL*{ETAT}) & not(((1..3)*{ETAT}) = {}) & OBJET: FIN(INTEGER) & not(OBJET = {});
objet : POW( OBJET) & categorie : objet +-> ((1..2)*{CATEGORIE}) & dom(categorie) = objet & ((categorie) : (((objet) --> (((1..2)*{CATEGORIE}))))) & etat : objet +-> ((1..3)*{ETAT}) & dom(etat) = objet & ((etat) : (((objet) --> (((1..3)*{ETAT}))))) & position : objet +-> (NAT * NAT) & dom(position) = objet & ((position) : (((objet) --> ((NAT * NAT))))) & !(obj,pos).(((((obj) : (OBJET)) & ((pos) : ((NAT * NAT))) & ((((obj) |-> (pos))) : (position))) => (#(cat).(((cat) : (((1..2)*{CATEGORIE}))) & ((cat) = ((1|->CATEGORIE))))))) & !(obj1,obj2,pos1,pos2).(((((obj1) : (OBJET)) & ((obj2) : (OBJET)) & ((pos1) : ((NAT * NAT))) & ((pos2) : ((NAT * NAT))) & ((((obj1) |-> (pos1))) : (position)) & ((((obj2) |-> (pos2))) : (position))) => (not(pos1 = pos2)))) & ((incompatible) : (((OBJET) <-> (OBJET)))) & !(obj1,obj2).(((((obj1) : (OBJET)) & ((obj2) : (OBJET)) & ((((obj1) |-> (obj2))) : (incompatible))) => (#(et1,et2).(((et1) : (((1..3)*{ETAT}))) & ((et2) : (((1..3)*{ETAT}))) & ((not(et1 = (1|->ETAT))) or (not(et2 = (1|->ETAT)))) & ((((obj1) |-> (et1))) : (etat)) & ((((obj2) |-> (et2))) : (etat))))));
((categorie) = (categorie$1)) & ((etat) = (etat$1)) & ((incompatible) = (incompatible$1)) & ((objet) = (objet$1)) & ((position) = (position$1));
((obj) : (OBJET)) & not(obj : objet) & ((cat) : (((1..2)*{CATEGORIE}))) & not({((obj) |-> (cat))} : POW( categorie));
"Refinement is correct";
"Check invariant ((categorie) = (categorie$1))";
((((categorie) \/ ({((obj) |-> (cat))}))) = (((categorie$1) \/ ({((obj) |-> (cat))}))));
"Check invariant ((etat) = (etat$1))";
((((etat) \/ ({((obj) |-> ((2|->ETAT)))}))) = (((etat$1) \/ ({((obj) |-> ((2|->ETAT)))}))));
"Check invariant ((objet) = (objet$1))";
((((objet) \/ ({obj}))) = (((objet$1) \/ ({obj}))));
((obj) : (OBJET)) & ((obj) : (objet)) & {((obj) |-> ((1|->CATEGORIE)))} : POW( categorie) & not({((obj) |-> ((1|->ETAT)))} : POW( etat)) & not({((obj) |-> ((3|->ETAT)))} : POW( etat)) & {((obj) |-> ((2|->ETAT)))} : POW( etat);
(((((etat - {((obj) |-> ((2|->ETAT)))})) \/ ({((obj) |-> ((1|->ETAT)))}))) = ((((etat$1 - {((obj) |-> ((2|->ETAT)))})) \/ ({((obj) |-> ((1|->ETAT)))}))));
((obj) : (OBJET)) & ((obj) : (objet)) & not({((obj) |-> ((2|->ETAT)))} : POW( etat)) & not({((obj) |-> ((3|->ETAT)))} : POW( etat)) & {((obj) |-> ((1|->ETAT)))} : POW( etat);
(((((etat - {((obj) |-> ((1|->ETAT)))})) \/ ({((obj) |-> ((2|->ETAT)))}))) = ((((etat$1 - {((obj) |-> ((1|->ETAT)))})) \/ ({((obj) |-> ((2|->ETAT)))}))));
!(obj,cat).(((((obj) : (OBJET)) & ((cat) : (((1..2)*{CATEGORIE}))) & ((((obj) |-> (cat))) : (categorie)) & ((cat) = ((2|->CATEGORIE)))) => (#(et).(((et) : (((1..3)*{ETAT}))) & ((((obj) |-> (et))) : (etat)) & ((et) = ((2|->ETAT)))))));
((obj$1) : (OBJET));
((cat$1) : (((1..2)*{CATEGORIE})));
((et$1) : (((1..3)*{ETAT})));
((((obj$1) |-> (cat$1))) : (categorie$1));
((cat$1) = ((2|->CATEGORIE)));
((((obj$1) |-> (et$1))) : (etat$1));
((et$1) = ((2|->ETAT)));
#(obj).(((obj) : (OBJET)) & ((((obj) |-> ((2|->CATEGORIE)))) : (categorie)) & ((((obj) |-> ((2|->ETAT)))) : (etat)) & (((((etat - {((obj) |-> ((2|->ETAT)))})) \/ ({((obj) |-> ((1|->ETAT)))}))) = ((((etat$1 - {((obj$1) |-> ((2|->ETAT)))})) \/ ({((obj$1) |-> ((1|->ETAT)))})))));
((res) = (res$1));
((((etat)~ )[{(1|->ETAT)}]) = (((etat$1)~ )[{(1|->ETAT)}]));
((((etat)~ )[{(3|->ETAT)}]) = (((etat$1)~ )[{(3|->ETAT)}]));
((objet) = (objet$1));
((incompatible) = (incompatible$1));
((etat) = (etat$1));
((categorie) = (categorie$1));
((((obj) |-> (et))) : (etat$1));
((cat) = ((2|->CATEGORIE)));
((((obj) |-> (cat))) : (categorie$1));
((et) : (((1..3)*{ETAT})));
((cat) : (((1..2)*{CATEGORIE})));
((obj) : (OBJET))
END
&
THEORY EnumerateX IS
CATEGORIE == {mobile,fixe};
ETAT == {actif,inactif,invalide}
END
